from pwn import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import time

def get_random_number(seed):
    seed = int(str(seed * seed).zfill(12)[3:9])
    return seed

def encrypt(message, seed):
	key = b''
	for i in range(8):
		seed = get_random_number(seed)
		key += (seed % (2 ** 16)).to_bytes(2, 'big')
	cipher = AES.new(key, AES.MODE_ECB)
	ciphertext = cipher.encrypt(pad(message, AES.block_size))
	return key.hex(), ciphertext.hex()

def decrypt(message, seed):

	key = b''
	for i in range(8):
		seed = get_random_number(seed)
		key += (seed % (2 ** 16)).to_bytes(2, 'big')

	cipher = AES.new(key, AES.MODE_ECB)

	plaintext = cipher.decrypt(message)
	return plaintext , key.hex()

pt = b'aaaaaaaaaaaaaaaa'
conn = remote('betta.utctf.live', 2435)

for j in range(3):

	print(conn.recvuntil(b')?'))
	conn.sendline(b'2')
	conn.recvline()
	conn.sendline(pt)
	conn.recvuntil(b': ')
	hexct = conn.recvline().decode().strip("\r\n")
	print(hexct)
	conn.recvline()

	for i in range(10 ** 6):

		key = encrypt(b"random text to initalize key", i)[0]

		ct = bytes.fromhex(hexct)

		ptDecrypted, key = decrypt(ct, i)
		#print(ptDecrypted)
		#print(key)
		#print(len(ptDecrypted))

		if pt in ptDecrypted:
			print(key)
			conn.sendline(b'1')
			conn.recvuntil(b')?')
			conn.sendline(key.encode())
			break


print(conn.recvall())
conn.close()

#utflag{ok_you_are_either_really_lucky_or_you_solved_it_as_intended_yay}